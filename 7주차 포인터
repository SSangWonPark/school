#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main() {

	float a;
	int s = 39;
	int sb = 6;
	 
	a = s / (float)sb;

	printf("%f", a);

	return 0;
}

// 포인터 상수는 배열의 주소.
// 포인터 변수는 메모리의 번지(주소)를 저장하는데 쓰이는 변수.
// 
// char, short, int 각각 다음 주소는 1바이트, 2바이트, 4바이트
// 다음을 아는 것이 중요하다. 그 다음 주소가 어디인지. 
// 주소는 무조건 바이트 단위.
// 
// int *p;	p는 int 주소이다. *p는 int형이다.
// struct 와 같이 사용자 지정의 크기도 포인터로 가리키며 연산할 수 있다.
// 
// int *p,i;	(p자체의 주소와 p가 가리키는 주소 두 가지를 건드릴 수 있다.)
// p = 0; p = NULL;	(두 가지 모두 0번지를 넣는다는 이야기)
// p = &i;	(p에 i의 주소를 넣는다.)
// p = (int *) 1776;	(절대주소를 넣어줌. 일반적으로 사용하지 않으나 임베디드에서는 사용함)
// 
// &연산자. &p는 p의 주소를 돌려주는 연산자이다.
// 배열에서 쓰이는 [] 도 연산자이다.
// 
// #define의 의미 : define MOD 1000 에서 MOD을 만나면 1000으로 바꾼다. 사람이 편할려고 만들었다.
// 함수가 아니라 소스 단위에서 사용된다.
// 
// float a;
// int s = 39;
// int sb = 6;
// 
// a = s/sb;	(a의 값은 6.0)
// a = (float)s / (float) sb;	(a의 값은 6.5) (둘 중 하나만 float형으로 해도 6.5가 나옴)
//
// 변수끼리의 주소가 무조건 연이어 있지는 않는다.
// int c[10],a[10],b[10]; 로 만들었을 때,
// 각각의 주소 c, a, b 상대주소가 0,48,96이라고 할 때,
// b[10], b[11]은 각각 a[-1], a[-2]와 동일하고, b[10]은 a[0]과 동일하다.
// 우연하게 이렇게 연속적으로 나왔기 때문에 가능하다. 항상 이런 것은 아니다.
// 
// a[100]을 생성했을 때 주소는 전자적으로 처리해줄 뿐 실제로 존재하지는 않는다.
// a 자체도 실제로 존재하는 것은 아님. 소스 상으로만 존재. 그저 a[0], a[1] ... a[99]가 존재할 뿐.
// 주소 계산은 컴파일러가 다 해줌. 
// 
// int a[100]; int *iptr;
// iptr = a;
// 여기서 존재하는 건 iptr의 주소, a[0]부터 a[99] 까지 100개 따라서 404바이트만 존재.
// 
// *(iptr+0) == a[0] (둘이 같음)
// *( + )와 [] 은 완전히 동일한 의미이다.
// 여기서 +는 다음 주소를 의미.
// ex) a[2] == *(a + 2)
// ex) a[-2] == *(a + (-2)) == *((-2) + a) == (-2)[a] <= 이게 왜 되지 싶지만 됨. 진짜 왜 되지.
//
// big endian : 낮은 번지에 높은 데이터값 저장 (보이는 순서대로 들어감)
// 0x10 0x11 0x12 0x13 <= 주소
// 0x12 0x34 0x56 0x78
// little endian : 낮은 번지에 낮은 데이터 값 저장 (보이는 것과 반대로 들어감) (인텔 방식)
// 0x10 0x11 0x12 0x13 <= 주소
// 0x78 0x56 0x34 0x12
//

//
// unsinged char *p1, *p2, a[100] = {0,}, b[2][3][5], c = 7, d = 128;
// int i = 1029, *ip;
// 
// p1 = &i;
// ip = &c;
// *p1 = 257;	// 255 이상의 값을 넣음. 데이터가 날아갈 것이다. 1만 남는다.
// *ip = 0x06070809;
// 
// i = 1025	// 1024 + 1 로 바뀜
// *p1 = 1	// 255이상으로 데이터가 날라감 2바이트쪽은 날아갔음
// c = 9	// *ip 로 넣은 값의 영향으로 09만 남음.
// d = 128
// *ip = 0x06070809	// 나중에는 09말고는 바뀔 수 있나?
//
// unsinged char *p1, *p2, a[100] = {0,}, b[2][3][5], c = 7, d = 128;
// int i = 1029, *ip;
// 
// ip = &a[3];	// a[3]부터 4바이트를 가져옴
// *ip = 0x06070809;	// 뒤집어져서 4바이트가 저장됨. 0x09080706으로
// 
// a[0] a[1] a[2] a[3] a[4] a[5] a[6] a[7]
// 0	0	 0	  09	08	 07	  06   0
// 
// char c = 5, d= 6, e = 0xEC;
// char ca[5] = {'p','q','r','s','t'}, da[5];
// int i = 50, j = 50, k = 0xF8;
// int ia[5] = { 16, 32,  64, 1, 4 };
// char *cp, *dp;
// int *ip, *jp;
// 
// 1. ca[5]에는 NULL 값이 없다. 문제가 있는가? 없다. 이유는? 상관없기 때문, 그러나 문자열로는 못쓴다.
// 2. ca[4] = 'X'는 가능한가? 가능하다.
// 3. printf("%s", ca);는 문법적인가? 문법적이다. 형식이 틀리지 않았다. c는 내용을 보지않는다. 책임지지않는다.
// 문제점은 있는가? 있다. 무엇인가? 문법적으로는 맞지만 내용적으로 틀렸다. 널문자가 없기때문에
// 결과는 ca값들이 나오고 널문자가 우연히 나오기 전까지 쓰레기값들을 출력함.
// 
// 1. cp = (char*)ia; 맞겠는가? 맞다. 무슨 뜻? 캐스팅해서 4바이트를 1바이트씩 읽을 수 있다. 혹은 비트연산으로 구할 수 있다.
// 2. cp 의 값은 얼마인가? ip 이유는? 주소이기 때문에
// *cp 는 0x10이 나옴.
//
// call by Reference
// 함수의 인자를 직접 접근하게 하는 전달 방식
// C에서는 call by value를 기본으로 사용한다
// - 함수의 인자로 값을 복사해서 그대로 전달한다.
// call by reference 효과르 위해 포인터 변수를 이용한다.
// - 인자로 값을 던져는 것은 맞는데, 그 값이 '주소'이기때문에 참조가 가능하고, 그래서 call by reference라고 한다.
// 
// *로 그 주소의 값을 핸들링할 수 있다.
// *( + ) 과 []은 같다. *(p + 5) == p[5]
//
// Q. *p 대신 p[]로 받아도 되지 않나요?
// 
// Q. 대입할 때 바이트에 숫자들이 거꾸로 바뀌는 것 같다. a에 있는 0x01020304가 04030201,로 저장되다가 b에 대입하면 어떻게 되나.
// 
// 함수에서 주소를 넘기는 경우, 위험함.
// 함수가 끝난 상태이기 때문에 받은 주소가 보호받지 못함. 
// 다른 함수나 변수들이 주소를 침범할 수 있다. 문법적으로는 옳으나 내용이 좀 그렇다.
// 이 주소를 보호할 거면 스태틱으로 힙영역에 생성되게 해주면 된다.
// 함수에서 주소를 돌려주는 것을 주의해라.
//
