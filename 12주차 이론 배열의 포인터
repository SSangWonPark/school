#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	
	char p2[101], *p3, *p4[5], i = 0, j = 0;

	scanf_s("%s", p2, 100);
	printf("%s\n", p2);

	p3 = &p2[0];	// p3는 p2를 핸들링할 포인터
	p4[j++] = p3;	// p4는 배열의 포인터. 단어위치저장

	while (*p3)
	{
		if (*p3 == 'x')	// 'x'를 찾아야지?
		{
			*p3 = 0;	// x를 찾으면 해야할 일 2가지 NULL 만들고, 위치 기억
			p4[j++] = p3 + 1;
		}
		p3++;	// 다음 위치로 이동
	}	// 반복해서 완성

	for (int i = 0; i < j; i++)
	{
		printf("%s\n", p4[i]);	// 배열의 포인터를 이용해서 출력
	}

	// x를 무한히 늘리려면? *p4[5]를 **p4로 바꾼 후 malloc

	return 0;
}

// char *p1 = NULL, p2[100], *p3, *p4[5];
// scanf_s("%s", p1, 100); // 이건 안됨.
// scanf_s("%s", p2, 100); // 이건 됨.
//
// 복합 포인터(배열의 포인터)
// 
// 포인터로 가면 값이 있는게 아니라 배열이 있다.
// 
// 배열을 함수로 넘길 때, 
// 시작은 알려주지만 끝을 알려주지 않는다. 배열이 몇개인지는 알 수 없다.
// 끝을 아는건 문자열 뿐. 나머지는 프로그래머가 알아서.
// 
// int arr2[10][10]을 함수로 받을 때, int **arr2로 받을 수 없음. 10개짜리 덩어리라는 것을 모름.
// int arr1[10]은 int *arr1은 가능.
// 
// 다차원 배열에 맞는 '포인터'가 필요함.
// arr2[10][10]에서 arr2 이름 하나로 모든 덩어리를 제어할 수 있는 것처럼 맞춤형 포인터가 필요.
// 다차원 배열을 그대로 표현할 수 있눈 것이 바로 배열의 포인터.
// 
// int arr[2][4]를 int (*arr)[4]로 표현가능. 4칸씩 움직인다는 맞춤형 정보를 가짐.
// int형 포인터인데 4개짜리 덩어리를 가진 변수다를 알려줌. 끝은 없음. c언어 특징 
// 
// 만약 char a[2][3][4][5][6]; 이 있다면 char (*p)[3][4][5][6]으로 표현 가능. 가장 큰 덩어리를 제외하고 표현하면 됨.
// 
// 매개변수로써 쓸 때는 int (*ptr)[4]는 int ptr[][4]로 써도 가능. 
// 그러나 변수 선언시에는 구분해야 함. 
// 
// int arr1[2][4] = { 1,2,3,4,5,6,7,8 };
// int (*ptr)[4] = arr1;	// 가능
// int ptr[][4] = arr1;		// 불가능, 초기화 필요
// 
// 배열의 포인터와 포인터의 배열
// 각각 다차원 배열, 더블 포인터와 파트너
// int (*ptr)[4], int* ptr[4]
// 
// 사진찍은 거 공부하기!!
//
