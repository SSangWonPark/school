// 변수 : 메모리 공간
// 먼저 만들수록 큰 주소 : 스택
// 먼저 만든 변수가 주소가 큰 값을 가짐.
// 
// 에러 : 문법적으로, 틀렸다.
// 경고 : 옳으나 뭔가 이상하다.
// 문법적으로는 형식과 같음. 심지어 -2[a]도 문법적으로 옳음
// 
// '문자열을 저장한다'는 것과 '문자를 저장한다'는 것은,
// '저장하는 시점'에서 매우 중요하고, '사용하는 방법'에서 매우 중요하다.
//
// char a[12] = "I am a boy.";
// a == &a[0]
// a 는 포인터상수이다. (번경불가, 할당받음)
// 변수 L-value (Left Value)
// 변수만 = 왼쪽에 나올 수 있음. (상수는 불가)
// char a[3][4][5][6] ... 고차원 배열에서 a는 &a[0] &a[1] 이런 식으로 올라감. a[3]이 제일 큰 영역
// c언어에서 포인터 - 포인터는 가능, 포인터 + 포인터는 불가능
// ex)	&a[2] - &a[0] <- 가능
//		&a[2] + &a[0] <- 불가능
// 
// 문자열을 만들면 read only memory 에 문자열을 복사 => 문자열을 만들면 두 곳에 존재함
// 문자열 초기화 시에 scanf로 받으면 복사본 없이 변수공간에만
// 여러개 문자열 존재 시, 문자열이 동일하면 복사는 1회만 하고 위치만 추가함.
// ex) 4개의 I am a boy를 만들면 문자열은 5개 존재 (변수 영역에 4개 + 복사본 1개)
// 
// char c[12] int i[12] 에서 &c[2] - &c[0]와 &i[2] - &i[0] 둘다 2이다.
// 값이 아니라 데이터의 개수가 반환된다. (2와 8이 아니다.)
// 주소에서 + 와 - 는 "다음"과 "이전"의 의미이다.
// 각각을 주소가 아닌 주소값이라고 생각하려면 앞에 캐스팅을 한다.
// ex) (int) &i[2] - (int) &i[0] <= 8이 나옴.
//
// 중요) 비트, 바이트 잘 해라.
