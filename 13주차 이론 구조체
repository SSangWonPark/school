#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	int a = 0;

	scanf("%d", &a);
}

// 구조체 
// 한 개 이상의 원소들로 이루어진 통합 자료형.
// 복잡한 자료들을 하나의 단위로 일괄처리하는데 유용.
// 구조체 정의란 구조체의 명칭과 구조체 멤버 변수들을 선언해 주는 것.
// 태그 : 대표하는 구조체 명칭
//
// struct 구조체명칭 {
// 멤버 변수1;
// 멤버 변수2;
// }구조체변수명;
// 
// 변수를 선언해야 그때서야 메모리에 생성됨. 이전까지 구조는 영역이 생성되지 않음.
// 모양만 선언한 것이고 변수를 만들어야 영역이 잡힘.
// 
// 도트 연산자
// 형태 : 구조체변수명.멤버변수
// 
// 멤버변수의 순서가 바뀌면 메모리 영역이 달라질 수 있음.
// 
// 같은 구조체명을 가지는 구조체끼리의 치환가능. 한번에 전달가능.
// var1 = var2; 할당문으로 한번에 복사 가능. 단, 비교문 불가능.
// 
// Q. 메모리를 복사하는 것으로 한번에 가능한데 메모리 간에 비교는 불가??? 메모리 영역의 크기가 다를 가능성이 있는가?
// Q. 메모리 사이즈만 같으면 구조체변수명이 달라도 복사가 가능할까?? 
// 
// 구조체 변수의 초기화
// 
// struct 구조체명칭 구조체변수명 = {초기값1, 초기값2 ...};
// 
// struct birthday{
// int year;
// int month;
// int day;
// char calendar;
// }kim;
// 
// 13바이트를 차지하는 것 같지만 절대 그렇지 않다. 
// 4의 배수로 가져오기 때문에 16을 가져오고 3을 지우는 과정을 계속함.
// pc에서는 상관없지만 임베디드같은 경우 문제가 생김. 클락단위로 민감하게 판단해야 하면 문제가 생김.
// 
// 패딩. padding
// 위처럼 13바이트를 가져올 때 16바이트를 가져옴.
// 3바이트의 빈 공간을 패딩이라고 함. 메모리를 효율적으로 처리.
// 
// #pragma 컴파일러 지시
// #pragma pack(n) // n = 1, 2, 4, 8 ... 
// 로 기준 바이트의 단위를 조절할 수 있다.
// 
// int/ char 구조체에서 일반 구조체/32비트 환경이면 사이즈가 8이겠지만,
// pack(1)을 하면 사이즈가 5가 된다. 강제로 맞춰주는 것이기 때문에 속도는 느려짐.
// 컴퓨터가 원하는대로 하는 것이 속도의 효율과 공간의 효율이 높다.
// 
// struct tmp{
// char
// char
// char
// char
// double
// double
// double
// double
// }
// 40바이트가 만들어진다. (36이 아니다. double을 보고 가장 효율적으로 8로 보고 40바이트를 만든다.)
// 
// struct tmp1{
// char
// double
// char
// double
// char
// double
// char
// double
// }
// 64바이트가 만들어진다. (36도 40도 아니다. 효율적으로 모두 8로 본다.)
// 
// 속도위주로 볼지 공간위주로 볼지도 나뉜다. 
// 
//
// 공부!! 프로파일링! 최적화! 이 두 가지 공부해봐라!!
//  
//
// 구조체 배열
// 구조체가 배열의 요소이고 배열의 원소가 구조체.
// 
// struct book{
// char title[5];
// int year;
// int price;
// }room[10];
// 
// room[4].price = 2000;
// room[2].title[1] = 'a';
// room[5].title = "lang"; // 이거 되는지 확인해보자! 안된다! 하나씩 
// 
// 구조체 포인터
// 구조체에 대한 포인터를 선언한 것. 단지 주소만 만든다. 4바이트.
// 
// struct 구조체명칭 {
// 멤버 변수1;
// 멤버 변수2;
// }*포인터변수명;
// 포인터변수에 주소를 담고 있다. 4바이트
// 
// struct book *room;
// struct book class;
// room = &class;
// 
// 화살표 연산자. ->
// 간접 멤버 참조 연산자
// 
// 구조체포인터변수명->멤버변수;
// struct 이름 *p;
// p는 구조체 포인터 변수
// 
// *는 멤버연산자(.)보다 낮은 우선순위를 갖기 때문에 (*구조체포인터변수명).멤버변수 형태로 써야한다.
// (*p).i 처럼 사용해야 함. p->i와 동일. *p.i로 사용하면 안된다.
// 
// 중첩된 구조체
// 구조체가 다른 구조체를 포함하는 경우. 멤버의 연산자를 반복해서 사용해 참조가능.
// 중첩된 구조체에서는 가장 바깥에서 참조를 시작하여 가장 안쪽에서 끝난다.
// 
// 자기 참조 구조체
// 구조체에 자신의 구조체를 다시 넣어 사용.
// 
// struct list{
// char name[20];
// char address[80];
// int age;
// struct list wow;	// 불가능. 아직 선언되지 않아서 불가능함.
// struct list *next;	// 가능. 포인터변수에 경우 주소이기 때문에 가능. 4바이트짜리 영역임.
// }
// 
// 리스트, 더블 링크드 리스트, 큐 등에서 자기 참조 구조체를 가지고 있음.
// 
// 비트 필드 구조체
// 구조체의 원소들을 비트들로 지정한다.
// 메모리를 절약하는 임베디드, 하드웨어 쪽에서 많이 사용한다.
// 따라서 on/off 정보를 유지하는 플래그로 많이 사용한다.
// 
// struct 구조체명칭{
// 데이터형 비트변수1 : 비트길이;	// 비트길이로 비트를 제한함.
// 데이터형 비트변수2 : 비트길이;	// 해당 비트길이만큼만 할당.
// }구조체변수명;
//
// 위부터 LSB로 2^0부터 채워짐.
// Q. 비트단위의 변수를 만들 수 있는데 구조체명칭으로 저 통째로 사용가능한가??
// ex) 0 1 1 11 0 1 1  로 채워져 있다면 각각 1 1 1 2 1 1의 길이를 가짐.
// 
// 비트필드를 포함하는 구조체 내에 일반변수도 사용가능. 혼용가능.
// 비트들의 합이 1바이트, 1워드 크기가 될 필요 없다. 
// 
// 비트 필드를 사용할 때 모든 비트에 이름을 부여할 필요는 없다.
// struct b_type{
// unsigned first: 1;
// unsigned : 6;	// 변수이름이 없음. 패딩임.
// unsigned last: 1;
// }
// 
// struct b_type{
// unsigned char first: 4;
// unsigned char second: 3;
// unsigned char : 1;	// 패딩
// unsigned char third: 8;
// }	// 분리해서 볼 수 있어서 효율적임.
//
// unsigned: 0; 은 비트 크기를 0으로 지정하는 것.
// 이런 경우 경계를 나눔. 줄바꿈같은 느낌.
// 
// 구조체와 함수
// 구조체는 할당이 가능하기 때문에 함수의 인자로도, 반환으로도 사용이 가능하다.
// 구조체 멤버 데이터의 전달, 구조체 멤버의 주소 전달, 구조체 변수의 전달, 구조체 변수의 주소 전달 모두 가능
// 각각 피호출 함수의 형식을 해당 전달형과 맞춰주어야 함.
//
