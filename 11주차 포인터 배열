#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {

	return 0;
}

//
// 포인터
// int i = 100;	// i는 int형 변수
// int *p = &i;	// p는 i를 가리키는 포인터
// int **q = &p;	// q는 포인터 p를 가리키는 이중포인터
// 
// 주소는 1바이트를 가리킴.
// 배열은 처음부터 끝까지 있어야 한다. 
// 필요할 때만 사용하기 위해 메모리를 효율적으로 하기 위해 포인터를 이용한다.
// 
// void set_proverb(char *q);
// 
// int main(void)
// {
//	char *s = NULL;
//	
//	set_proverb(s);
//	printf("%s", s);
// 
//	return 0;
// }
// 
// void set_proverb(char *q)
// {
//	static char *str1 = "A friend in need is a friend indeed";	// static을 사용하면 다른 영역에 할당해서 
//	static char *str2 = "A little knowledge is a dangerous thing";	// 그 함수에 들어오면 다시 사용할 수 있다. private
// 
//	q = str1;
// }
// 
// s에 str1의 값을 주고 싶어하는 것 같지만, 함수에 들어갈 때 값의 복사본이 들어가기 때문에 되지 않는다.
// s를 바꾸고 싶다면 s의 주소를 주었어야 함. s의 주소를 주었다면 가능함.
// 
// &s로 넘겨주고 char **q로 받아서 레벨을 맞춰주어야 함. *q = str1을 한다면 s에 str1의 주소가 들어가 가능함.
// 
// void 포인터 하나 가지고 캐스팅하면서 할당하면 좋음. 개수를 줄일 수 있음. 
// 다만 읽어야 의도를 알 수 있다. 코드의 가독성은 떨어지지만 효율성이 높다.
// 
// 
// 포인터의 배열
// 동적 할당
// int** 어딘가에 있다.
// int* 어딘가에 반드시 붙어있다. 끼리끼리 있음.
// int 어딘가에 반드시 붙어있다. 끼리끼리 있음.
// 
// 포인터 배열: 포인터를 모아서 배열로 만든것. 각각이 주소임.
// int a = 10, b = 20, c = 30, d =40, e = 50;
// int *pa[5] = {&a, &b, &c, &d, &e};	// 초기값으로 각 데이터의 주소를 받음.
// 나란히 5개가 있고, 중구난방인 a,b,c,d,e의 주소를 넘겨줌.
// 
// 동적할당에서 맨 처음 더블포인터로 하는 과정이 없어진 것과 동일함.
// 동적할당은 끼리까리 모여있어서 +1을 하면 영역이 있지만 포인터 배열은 영역을 보장하지 않음.
// 
// char *fruits[] = {
//	"apple",
//	"blueverry",
//	"orange",
//	"melon"
// };	// 포인터 배열은 주소만 가진다. 캐릭터 주소 배열
// 텍스트 영역에 각각 문자열이 존재하고 그 주소를 가지고 있음.
// fruits[]는 16바이트짜리. 4개의 변수 공간에 각각 4바이트씩 가지고 있기 때문. 4바이트? 주소가 4바이트
// 2차원 배열처럼 fruits[0][1] 이런 식으로 가져올 수 있다. 4*4의 공간인데 그 주소의 값에 가서 확인 가능.
// 
// 확인해보기!
// fruits
// &fruits
// &fruits[0]
// fruits[0]
// fruits[0][0]
// 
// 텍스트공간은 읽을 수는 있으나 쓸 수 없는 공간이다.
// 따라서 수정이 불가능하다. 빈 공간에 동적할당해서 만들었다면 변수공간이라 가능하다.
// 텍스트공간을 가리키다가 아무것도 가리키지 않는다면 그 공간을 다신 찾을 수 없음.
// 
// Q. 일반적인 char c[] = "apple";라면 텍스트영역에 생긴 "apple"의 복사본을 받음. 포인터 배열도 주소를 가짐. 똑같은 거 아닌가..?
// A. 배열은 변수공간을 만드는 것. 포인터 배열은 텍스트영역에만 존재. 복사본 X 
// 
// char *fruits[] = {
//	"apple",
//	"blueverry",
//	"orange",
//	"melon"
// };	16바이트의 변수 공간, fruits[0][0] 수정 불가
// 
// char fname[][10] = {
//	"apple",
//	"blueverry",
//	"orange",
//	"melon"
// };	40바이트의 변수 공간, fname[0][0] 수정 가능
// 
// char **p;
// p = fname[0];	// 돌아간다. 그러나 원하는대로가 아니다. 레벨이 맞지 않는다. fname[0]은 *p와 레벨이 맞다. 
// 값에 몇번이면 도달하는지 생각하자.
// p = fname;	// 돌아간다. 원하는대로 된다. 레벨이 맞는다. fname -> fname[0] -> fname[0][0] 값에 2번째 도달.
// 
// char **p;
// p = fruits[0];	// fruits는 1차원 배열임. 레벨이 맞지 않는다. fruits[0] -> 'a' 1번밖에 들어가지 못함.
// p = fruits;	// 레벨이 맞는다. 잘 돌아간다. fruits -> fruits[0] -> 'a'	2번 들어가서 가능.
// p[0][1] == 'p', p[0] = "apple"
//
