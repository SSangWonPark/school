#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	

	return 0;
}
 
// 다차원 배열
// 
// int grade[SiZE];
// int score[SIZE];
// score = grade;	// 에러, 포인터 상수인 주소임. L-value가 아님.
// 값을 넣으려면 각각을 반복문을 돌려 하나씩 넣어주어야 함.
// 
// score == grade	// 에러도 워닝도 아님. 다만 다른 주소이기 때문에 항상 거짓임
// 각각을 비교해서 조건으로 사용해야 함.
// 
// 배열의 주소를 사용해 함수에 읽기 전용으로 주고 싶을 때 const 사용. 배열 원본 변경 금지
// 원본 배열에 대한 변경을 하지 못하게 함. 원본이 아닌 복사본을 줌.
// 
// const의 쓰임이 다양하기 때문에 다른 언어에서 사용할 시 확인할 필요가 있음.
// 
// char p1[] = "abcde";	// abcde의 복사본을 p1에게 넘겨줌.
// char *p2 = "abcde";	// abcde를 가리킴. 읽을 수만 있는 데이터. 텍스트 영역에 존재.
// char c2[] = {'a','b','c','d','e'};	// p1은 NULL이 존재하지만 c2는 없음. 문자열로 사용불가
// 
// int avg, *a;
// 
// avg = test(c2, p2);
// 
// int test(char c[], char d[]) / (char *c, char *d)와 동일
// 
// 다차원 배열을 쓰는 이유? 포인터를 사용하기 위해. 얼마만큼 넘어갈지 정할 수 있음.
// 컴퓨터의 캐시가 배열 데이터의 뭉텅이를 가져옴. 따라서 물리적인 1차원으로 가져오는 것이 좋음. a[y][x] 이면 x부터.
// 
// int *ip	// 어딘가에 4바이트짜리 공간이 있고 그곳에 주소를 저장한다. 그 주소로 가면 값이 있다.
// int **iip	// 어딘가에 4바이트짜리 공간이 있고, 주소를 저장해 그 주소로 가는데, 그 주소에는 *가 있다.
// **은 *의 주소를 가지고 *은 값의 주소를 가짐.
// 
// iip + 1은 무엇인가? iip가 가리키는 것은 주소임. 그 다음 영역을 가져와서 주소로 가져옴. 그곳에 값이 있어도 주소라고 생각함.
// 실제와 무관하게 그것이 가리키는 것에 따라 주소인지 값인지가 결정됨. **iip는 iip[][], 이차원배열과 같음.
// 
// int sum(int**grade)
// 함수의 인자로 **을 쓰는 경우, 몇개나 있는 배열인지 모름. 알 수 없음. 계산할 수 없다.
// 
// int sum(int gradep[][product])
// 뒤쪽에 배열의 사이즈는 넘겨주어야 한다.
// 
// 직접 배열과 포인터들을 그려서 확인해보자. 중요!
// 
// char *s1 = "Hello";	// 텍스트영역. 쓰기 불가능. s1은 자기 공간이 없음.
// 
// scanf("%s", s1);	// s1은 주소임. 쓸 공간이 아니다.
// 
// printf("%s", s1);	<== Q. 주소를 문자열 형으로 쓰는건 문제가 없나요? ppt p.15
// 
// 해결책. 동적할당. malloc
// 동적 : 프로그램 실행 중
// 
// (캐스팅 *)malloc(공간사이즈 * sizeof(자료형));
// free로 해제. window같은 os에 요청해서 받아오는 공간임.
// 
// 2차원 동적할당
// 
// int **pn = (int**)malloc(sizeof(int)*row*col); <== 컴파일은 되지만 원하는대로 되지 않음.
// 
// 정적으로 2차원 할당 -> 프로그램 시작부터 끝까지 그 메모리 영역이 필요. 무거워짐. 끝이 모두 붙어있음.
// 동적으로 2차원 할당 -> 프로그램 중 필요할 때만 사용하고 다시 넘겨줌. 상대적으로 가벼움. 붙어있지 않음.
// 
// 1차원 : pn = (int *)malloc(sizeof(int) * 100);
// 2차원 : 
//		int **m = (int **)malloc(sizeof(int *) * 3);
//		m[0] = (int *)malloc(sizeof(int) * 4);
//		m[1] = (int *)malloc(sizeof(int) * 4);
//		m[2] = (int *)malloc(sizeof(int) * 4);
// 
// 2차원 배열 m[3][4]와 동일한 연산이 가능하지만, 끝이 이어지지 않음 (m[0]과 m[1]이 연결되지 않음) 
// 
// Q. 2차원 동적할당 시에 m[0]에 4칸을 주고 m[1]에 3칸을 주는 식으로 달라도 되나요?
// 달라도 된다.
//
